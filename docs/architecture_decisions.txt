Components:
- Frontend
  - Handles UI and accepts user actions

- API
  - Accepts requests from Frontend service. 
  - Will act as a proxy and forward the requests to Core service.

- Core
  - Handles all the database logics.

- Consumer
  - Receive messages from Kafka and calls Core service to do the actually task.

Architecture Decision:

- Frontend will call API service using the REST API message passing.
  - It is customer facing. So, it's better to be less complex and better browser support.

- API service will call Core service using gRPC message passing.
  - Since gRPC uses protobuf, data is structed before storing into database.
  - Even though being more complex than the REST API to be used by clients, it will only be called by internal services.
  - The messages being transferred as bytes is more efficient.
  - So, I decided to use gRPC for internal message passing.

- Core service will asynchronously create locations using Kafka message passing.
  - Since the users will send their current locations periodically, the QPS will be high.
  - Adding a queue before storing into database, will avoid the bottleneck at the database.